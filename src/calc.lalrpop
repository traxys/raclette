use crate::{
	ast::{
		Token,
		Expr,
		Literal,
		Variable,
		BinOp,
		BinOpKind,
		UnaryOp,
		UnaryOpKind,
		InputStatement,
		Function,
		Call,
		UserParseError,
		DecimalLiteral,
		DimensionedExpr,
	},
	span::SpannedValue,
};
use std::sync::Arc;

use lalrpop_util::ParseError;

grammar(source: &crate::span::MaybeNamed);

extern {
	type Location = usize;
	type Error = crate::ast::UserParseError;

	enum Token {
		"(" => Token::LParen,
		")" => Token::RParen,
		"|>" => Token::Redirect,
		"||" => Token::LOr,
		"&&" => Token::LAnd,
		"|" => Token::BOr,
		"&" => Token::BAnd,
		"^" => Token::BXor,
		"=" => Token::Equal,
		"+" => Token::Plus,
		"-" => Token::Minus,
		"*" => Token::Times,
		"**" => Token::Power,
		"/" => Token::Divide,
		"//" => Token::IntDivide,
		">>" => Token::RShift,
		"<<" => Token::LShift,
		"%" => Token::Percent,
		"\\" => Token::Backslash,
		"." => Token::Dot,
		":" => Token::Colon,
		"'(" => Token::UnitParen,
		"," => Token::Comma,
		"as" => Token::As,
		"true" => Token::True,
		"false" => Token::False,
		"==" => Token::LogicalEquals,
		"!=" => Token::Different,
		">=" => Token::GreaterOrEqual,
		"<=" => Token::LesserOrEqual,
		">" => Token::Greater,
		"<" => Token::Lesser,
		num => Token::Number(<i128>),
		decimal => Token::Decimal(<DecimalLiteral>),
		ident => Token::Ident(<Arc<str>>),
		unit => Token::Unit(<Arc<str>>),
		binding => Token::Binding(<Arc<str>>),
	}
}

Spn<T>: SpannedValue<T> = {
    <start:@L> <value:T> <end:@R> => SpannedValue {
        start, 
        value, 
        end, 
        source: source.clone()
    }
};

Variable: Variable = ident+ => Variable(<>);
SpnBox<T>: Box<SpannedValue<T>> = Spn<T> => Box::new(<>);
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub InputStatement: SpannedValue<InputStatement> = Spn<InputStatementInner> => <>;

DimensionedCast: DimensionedExpr = <expr:Spn<Expr>> "as" <unit:ManyUnit> => DimensionedExpr {<>};

InputStatementInner: InputStatement = {
	"|>" <Spn<Function>> => InputStatement::LastRedirect(<>),
	Expr => InputStatement::Expr(<>),
	SpnBox<DimensionedCast> => InputStatement::Expr(Expr::Dimensioned(<>)),
	"." <Spn<ident>> <CommandValue?> => InputStatement::Command(<>),
};

CommandValue: SpannedValue<Expr> = "=" <Spn<Expr>> => <>;

Function: Function = {
	Spn<Variable> => Function::Ref(<>),
};

pub Expr: Expr = {
	<Spn<Variable>> "=" <SpnBox<Expr>> => Expr::Assign(<>),
	ExprPipe => <>,
};

Redirect: Call = <val:Spn<ExprPipe>> "|>" <fun:Spn<Function>> => Call {fun, args: vec![val]};

ExprPipe: Expr = {
	Spn<Redirect> => Expr::Call(<>),
	ExprBoolOr => <>,
};

OpBoolOr: BinOp = <lhs:SpnBox<ExprBoolOr>> "||" <rhs:SpnBox<ExprBoolAnd>> => BinOp{<>, kind: BinOpKind::LogicalOr};

BinOp<T>: Expr = Spn<T> => Expr::BinOp(<>);

ExprBoolOr: Expr = {
	BinOp<OpBoolOr> => <>,
	ExprBoolAnd => <>,
};

OpBoolAnd: BinOp = <lhs:SpnBox<ExprBoolAnd>> "&&" <rhs:SpnBox<ExprCmp>> => BinOp{<>, kind: BinOpKind::LogicalAnd};

ExprBoolAnd: Expr = {
	BinOp<OpBoolAnd> => <>,
	ExprCmp => <>,
};

OpCmp: BinOp = {
	<lhs:SpnBox<ExprLOr>> ">" <rhs:SpnBox<ExprLOr>> => BinOp{<>, kind: BinOpKind::Greater},
	<lhs:SpnBox<ExprLOr>> ">=" <rhs:SpnBox<ExprLOr>> => BinOp{<>, kind: BinOpKind::GreaterOrEqual},
	<lhs:SpnBox<ExprLOr>> "<" <rhs:SpnBox<ExprLOr>> => BinOp{<>, kind: BinOpKind::Lesser},
	<lhs:SpnBox<ExprLOr>> "<=" <rhs:SpnBox<ExprLOr>> => BinOp{<>, kind: BinOpKind::LesserOrEqual},
	<lhs:SpnBox<ExprLOr>> "==" <rhs:SpnBox<ExprLOr>> => BinOp{<>, kind: BinOpKind::LogicalEquals},
	<lhs:SpnBox<ExprLOr>> "!=" <rhs:SpnBox<ExprLOr>> => BinOp{<>, kind: BinOpKind::Different},
};

ExprCmp: Expr = {
	BinOp<OpCmp> => <>,
	ExprLOr => <>,
};

OpLOr: BinOp = <lhs:SpnBox<ExprShift>> "|" <rhs:SpnBox<ExprAdd>> => BinOp{<>, kind: BinOpKind::BinaryOr};

ExprLOr: Expr = {
	BinOp<OpLOr> => <>,
	ExprLXor => <>,
};

OpLXor: BinOp = <lhs:SpnBox<ExprShift>> "^" <rhs:SpnBox<ExprAdd>> => BinOp{<>, kind: BinOpKind::BinaryXor};

ExprLXor: Expr = {
	BinOp<OpLXor> => <>,
	ExprLAnd => <>,
};

OpLAnd: BinOp = <lhs:SpnBox<ExprShift>> "&" <rhs:SpnBox<ExprAdd>> => BinOp{<>, kind: BinOpKind::BinaryAnd};

ExprLAnd: Expr = {
	BinOp<OpLAnd> => <>,
	ExprShift => <>,
};

OpShift: BinOp = {
	<lhs:SpnBox<ExprShift>> "<<" <rhs:SpnBox<ExprAdd>> => BinOp{<>, kind: BinOpKind::LeftShift},
	<lhs:SpnBox<ExprShift>> ">>" <rhs:SpnBox<ExprAdd>> => BinOp{<>, kind: BinOpKind::RightShift},
};

ExprShift: Expr = {
	BinOp<OpShift> => <>,
	ExprAdd => <>,
};

OpAdd: BinOp = {
	<lhs:SpnBox<ExprAdd>> "+" <rhs:SpnBox<ExprMult>> => BinOp{<>, kind: BinOpKind::Sum},
	<lhs:SpnBox<ExprAdd>> "-" <rhs:SpnBox<ExprMult>> => BinOp{<>, kind: BinOpKind::Diff},
};

ExprAdd: Expr = {
	BinOp<OpAdd> => <>,
	ExprMult => <>,
};

OpMult: BinOp = {
	<lhs:SpnBox<ExprMult>> "/" <rhs:SpnBox<ExprExpo>> => BinOp{<>, kind: BinOpKind::Divide},
	<lhs:SpnBox<ExprMult>> "*" <rhs:SpnBox<ExprExpo>> => BinOp{<>, kind: BinOpKind::Times},
	<lhs:SpnBox<ExprMult>> "%" <rhs:SpnBox<ExprExpo>> => BinOp{<>, kind: BinOpKind::Modulo},
};

ExprMult: Expr = {
	BinOp<OpMult> => <>,
	ExprExpo => <>,
};

OpExpo: BinOp = <lhs:SpnBox<ExprExpo>> "**" <rhs:SpnBox<ExprUnary>> => BinOp{<>, kind: BinOpKind::Power};

ExprExpo: Expr = {
	BinOp<OpExpo> => <>,
	ExprUnary => <>,
};

UnaryKind: UnaryOpKind = {
	"-" => UnaryOpKind::Minus,
	"+" => UnaryOpKind::Plus,
};

UnaryOp<T>: Expr = Spn<T> => Expr::UnaryOp(<>);

OpNeg: UnaryOp = <kind:UnaryKind> <operand:SpnBox<ExprLiteral>> => UnaryOp{<>};

ExprUnary: Expr = {
	UnaryOp<OpNeg> => <>,
	ExprLiteral => <>,
};

I64: i64 = <n:Spn<num>> =>? match (*n).try_into() {
	Err(_) => Err(ParseError::User {
		error: UserParseError::OutOfRange {
			ty: "i64",
			num: n.value,
			span: n.start..n.end,
		}
	}),
	Ok(n) => Ok(n),
};

Unit: (Arc<str>, i64) = {
	unit => (<>, 1),
	<u:unit> <n:I64> => (<>),
	"(" <u:unit> "-" <e:I64> ")"=> (u, -e),
};

UnitId: (Arc<str>, i64) = {
	ident => (<>, 1),
	ident I64 => (<>),
	<u:ident> "-" <e:I64> => (u, (-e)),
	"/" <ident> => (<>, -1),
	"/" <u:ident> <e:I64> => (u, (-e)),
};

ManyUnit: Vec<SpannedValue<(Arc<str>, i64)>> = {
	Spn<Unit>+ => <>,
	"'(" <Spn<UnitId>+> ")" => <>,
};

Call: Call = {
	<fun:Spn<Function>> "(" <args:Comma<Spn<Expr>>> ")" => Call { <> },
};

LiteralExpr: Expr = {
	Spn<Literal> => Expr::Literal(<>),
};

DimensionedExpr: DimensionedExpr = {
	<expr:Spn<LiteralExpr>> <unit:ManyUnit> => DimensionedExpr {<>},
	"(" <DimensionedCast> ")" => <>,
};

ExprLiteral: Expr = {
	LiteralExpr => <>,
	Spn<Variable> => Expr::Variable(<>),
	SpnBox<DimensionedExpr> => Expr::Dimensioned(<>),
	Spn<Call> => Expr::Call(<>),
	"(" <Expr> ")" => <>,
};

Literal: Literal = {
	num => Literal::Number(<>),
	decimal => Literal::Decimal(<>),
	"true" => Literal::Bool(true),
	"false" => Literal::Bool(false),
	":" <ident> => Literal::Atom(<>),
};
