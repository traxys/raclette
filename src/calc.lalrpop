use crate::{
	ast::{Token, Expr, Literal, Variable, BinOp, BinOpKind, InputStatement, Function, Call},
	span::SpannedValue,
};
use std::sync::Arc;

grammar(source: &crate::span::MaybeNamed);

extern {
	type Location = usize;
	type Error = crate::ast::UnknownToken;

	enum Token {
		"(" => Token::LParen,
		")" => Token::RParen,
		"|>" => Token::Redirect,
		"=" => Token::Equal,
		"+" => Token::Plus,
		"-" => Token::Minus,
		"*" => Token::Times,
		"**" => Token::Power,
		"/" => Token::Divide,
		"//" => Token::IntDivide,
		">>" => Token::RShift,
		"<<" => Token::LShift,
		"%" => Token::Percent,
		"\\" => Token::Backslash,
		"." => Token::Dot,
		":" => Token::Colon,
		"_(" => Token::UnitParen,
		"," => Token::Comma,
		num => Token::Number(<i64>),
		float => Token::Float(<f64>),
		ident => Token::Ident(<Arc<str>>),
		unit => Token::Unit(<Arc<str>>),
		binding => Token::Binding(<Arc<str>>),
	}
}

Spn<T>: SpannedValue<T> = {
    <start:@L> <value:T> <end:@R> => SpannedValue {
        start, 
        value, 
        end, 
        source: source.clone()
    }
};

Variable: Variable = ident+ => Variable(<>);
SpnBox<T>: Box<SpannedValue<T>> = Spn<T> => Box::new(<>);
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub InputStatement: SpannedValue<InputStatement> = Spn<InputStatementInner> => <>;

InputStatementInner: InputStatement = {
	"|>" <Function> => InputStatement::LastRedirect(<>),
	Expr => InputStatement::Expr(<>),
	"." <Spn<ident>> <CommandValue?> => InputStatement::Command(<>),
};

CommandValue: SpannedValue<Expr> = "=" <Spn<Expr>> => <>;

Function: Function = {
	Spn<Variable> => Function::Ref(<>),
};

pub Expr: Expr = {
	<Spn<Variable>> "=" <SpnBox<Expr>> => Expr::Assign(<>),
	ExprPipe => <>,
};

ExprPipe: Expr = {
	<val:Spn<ExprPipe>> "|>" <fun:Spn<Function>> => Expr::Call(Call {fun, args: vec![val]}),
	ExprAdd => <>,
};

ExprAdd: Expr = {
	<lhs:SpnBox<ExprAdd>> "+" <rhs:SpnBox<ExprMult>> => Expr::BinOp(BinOp{<>, kind: BinOpKind::Sum}),
	<lhs:SpnBox<ExprAdd>> "-" <rhs:SpnBox<ExprMult>> => Expr::BinOp(BinOp{<>, kind: BinOpKind::Diff}),
	ExprMult => <>,
};

ExprMult: Expr = {
	<lhs:SpnBox<ExprMult>> "/" <rhs:SpnBox<ExprLiteral>> => Expr::BinOp(BinOp{<>, kind: BinOpKind::Divide}),
	<lhs:SpnBox<ExprMult>> "*" <rhs:SpnBox<ExprLiteral>> => Expr::BinOp(BinOp{<>, kind: BinOpKind::Times}),
	ExprLiteral => <>,
};

Unit: (Arc<str>, i16) = {
	unit => (<>, 1),
	unit num => (<> as i16),
	"(" <u:unit> "-" <e:num> ")"=> (u, (-e) as i16),
};

UnitId: (Arc<str>, i16) = {
	ident => (<>, 1),
	ident num => (<> as i16),
	<u:ident> "-" <e:num> => (u, (-e) as i16),
	"/" <ident> => (<>, -1),
	"/" <u:ident> <e:num> => (u, (-e) as i16),
};

ManyUnit: Vec<SpannedValue<(Arc<str>, i16)>> = {
	Spn<Unit>+ => <>,
	"_(" <Spn<UnitId>+> ")" => <>,
};

Call: Call = {
	<fun:Spn<Function>> "(" <args:Comma<Spn<Expr>>> ")" => Call { <> },
};

ExprLiteral: Expr = {
	Spn<Literal> => Expr::Literal(<>),
	Spn<Literal> ManyUnit => Expr::DimensionalLiteral(<>),
	Spn<Variable> => Expr::Variable(<>),
	Call => Expr::Call(<>),
	"(" <Expr> ")" => <>,
};

Literal: Literal = {
	num => Literal::Number(<>),
	float => Literal::Float(<>),
	":" <ident> => Literal::Atom(<>),
};
