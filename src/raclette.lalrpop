use crate::{ast::{Expr, Statement, Token, Literal, BinaryOp, Place, Folder}, span::{SpannedValue, UNKNOWN_SPAN, SpanningExt}};
use std::rc::Rc;
use std::collections::HashMap;

grammar;

extern {
	type Location = usize;
	type Error = crate::ast::UnknownToken;

	enum Token {
		number => Token::Number(<i64>),
		ident => Token::Identifier(<String>),
		str => Token::String(<String>),
		"->" => Token::Arrow,
		"\\" => Token::Backslash,
		"&" => Token::And,
		"|" => Token::Pipe,
		"|>" => Token::Redirect,
		"%" => Token::Percent,
		"@" => Token::At,
		"\n" => Token::Newline,
		"(" => Token::LParen,
		")" => Token::RParen,
		"[" => Token::LBracket,
		"]" => Token::RBracket,
		"{" => Token::LBrace,
		"}" => Token::RBrace,
		"." => Token::Dot,
		"=" => Token::Equal,
		"," => Token::Comma,
		"~" => Token::Tilde,
		"+" => Token::Plus,
		"-" => Token::Minus,
		"*" => Token::Times,
		"/" => Token::Divide,
		"//" => Token::IntDivide,
		"**" => Token::Power,
		">>" => Token::RShift,
		"<<" => Token::LShift,
		":" => Token::Colon,
	}
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Spn<T>: SpannedValue<T> = {
	<start:@L> <value:T> <end:@R> => SpannedValue {start, value, end}
};

Literal: Literal = {
	number => Literal::Number(<>),
	str => Literal::String(<>),
};

pub Expr: Expr = {
	<lhs:Spn<Expr>> "|>" <rhs:Spn<FuncDef>> => {
		Expr::Binary(BinaryOp::Redirect, Box::new(lhs), Box::new(rhs))
	},
	<lhs:Spn<Expr>> "|>" <rhs:Spn<BOrExpr>> => {
		Expr::Binary(BinaryOp::Redirect, Box::new(lhs), Box::new(rhs))
	},
	<FuncDef> => <>,
	<BOrExpr> => <>,
};

FuncDef: Expr = {
	"\\" <args:Comma<ident>> "=" <ret:Spn<BOrExpr>> => Expr::FuncDef {
		args,
		ret: Box::new(ret),
	},
};

BOrExpr: Expr = {
	<lhs:Spn<BAndExpr>> "|" <rhs:Spn<BOrExpr>> => {
		Expr::Binary(BinaryOp::BitwiseOr, Box::new(lhs), Box::new(rhs))
	},
	<BAndExpr> => <>,
};

BAndExpr: Expr = {
	<lhs:Spn<ShiftExpr>> "&" <rhs:Spn<BAndExpr>> => {
		Expr::Binary(BinaryOp::BitwiseAnd, Box::new(lhs), Box::new(rhs))
	},
	<ShiftExpr> => <>,
};

ShiftExpr: Expr = {
	<lhs:Spn<ShiftExpr>> ">>" <rhs:Spn<MultExpr>> => {
		Expr::Binary(BinaryOp::RShift, Box::new(lhs), Box::new(rhs))
	},
	<lhs:Spn<ShiftExpr>> "<<" <rhs:Spn<MultExpr>> => {
		Expr::Binary(BinaryOp::LShift, Box::new(lhs), Box::new(rhs))
	},
	<MultExpr> => <>,
};

AddExpr: Expr = {
	<lhs:Spn<MultExpr>> "+" <rhs:Spn<AddExpr>> => {
		Expr::Binary(BinaryOp::Plus, Box::new(lhs), Box::new(rhs))
	},
	<lhs:Spn<MultExpr>> "-" <rhs:Spn<AddExpr>> => {
		Expr::Binary(BinaryOp::Minus, Box::new(lhs), Box::new(rhs))
	},
	<MultExpr> => <>,
};

MultExpr: Expr = {
	<lhs:Spn<PowerExpr>> "*" <rhs:Spn<MultExpr>> => {
		Expr::Binary(BinaryOp::Times, Box::new(lhs), Box::new(rhs))
	},
	<lhs:Spn<PowerExpr>> "%" <rhs:Spn<MultExpr>> => {
		Expr::Binary(BinaryOp::Modulo, Box::new(lhs), Box::new(rhs))
	},
	<lhs:Spn<PowerExpr>> "/" <rhs:Spn<MultExpr>> => {
		Expr::Binary(BinaryOp::Divide, Box::new(lhs), Box::new(rhs))
	},
	<lhs:Spn<PowerExpr>> "//" <rhs:Spn<MultExpr>> => {
		Expr::Binary(BinaryOp::IntDivide, Box::new(lhs), Box::new(rhs))
	},
	<PowerExpr> => <>,
};

PowerExpr: Expr = {
	<lhs:Spn<MapExpr>> "**" <rhs:Spn<PowerExpr>> => {
		Expr::Binary(BinaryOp::Power, Box::new(lhs), Box::new(rhs))
	},
	<MapExpr> => <>,
};


MapField: (SpannedValue<Expr>, SpannedValue<Expr>) = {
	<Spn<Expr>> "=" <Spn<Expr>> => (<>),
};

StringMap: (SpannedValue<Expr>, SpannedValue<Expr>) = {
	<k:Spn<ident>> "=" <v:Spn<Expr>> => (k.map(Literal::String).wrap(Expr::Literal), v)
};

MapExpr: Expr = {
	"~" "{" <Comma<StringMap>> "}" => Expr::Map(<>),
	"{" <Comma<MapField>> "}" => Expr::Map(<>),
	<TildeExpr> => <>,
};

TildeExpr: Expr = {
	"~" <Spn<TildeExpr>> => Expr::Tilde(Box::new(<>)),
	<CallExpr> => <>,
};

Named: (SpannedValue<Rc<str>>, SpannedValue<Expr>) = <n:Spn<ident>> "=" <v:Spn<Expr>> => (n.map(Rc::from), v);

NamedArgs: HashMap<SpannedValue<Rc<str>>, SpannedValue<Expr>> = <args:(<Named> ",")*> <last:Named?> => {
	let mut named: HashMap<_, _> = args.into_iter().collect();
	if let Some(last) = last {
		named.insert(last.0, last.1);
	}
	named
};

PosArgs: Vec<SpannedValue<Expr>> = Comma<Spn<Expr>> => <>;

CallExpr: Expr = {
	<func:Spn<CallExpr>> "(" <args:PosArgs> ")" => Expr::Call {
		func: Box::new(func),
		args,
	},
	<NamedCallExpr> => <>,
};

NamedCallExpr: Expr = {
	<func:Spn<NamedCallExpr>> "{" <named:NamedArgs> "}" => Expr::NamedCall {
		func: Box::new(func),
		named,
	},
	<PrefixMapperExpr> => <>,
};

BinaryOp: BinaryOp = {
	"|" => BinaryOp::BitwiseOr,
	"&" => BinaryOp::BitwiseAnd,
	"|>" => BinaryOp::Redirect,
	"+" => BinaryOp::Plus,
	"-" => BinaryOp::Minus,
	"*" => BinaryOp::Times,
	"/" => BinaryOp::Divide,
	"//" => BinaryOp::IntDivide,
	"**" => BinaryOp::Power,
	">>" => BinaryOp::RShift,
	"<<" => BinaryOp::LShift,
	"%" => BinaryOp::Modulo,
};

PrefixMapperExpr: Expr = {
	"@" <Spn<LiteralExpr>> => Expr::Mapper(Box::new(<>)),
	<LiteralExpr> => <>,
};

RangeExpr: Expr = {
	"[" <start:Spn<ShiftExpr>?> ":" <end:Spn<ShiftExpr>?> "]" => Expr::Range {
		start: Box::new(start.unwrap_or_else(||
			Expr::Literal(Literal::Number(0).spanned(UNKNOWN_SPAN)).spanned(UNKNOWN_SPAN))
		),
		end: end.map(Box::new),
		step: Box::new(Expr::Literal(Literal::Number(1).spanned(UNKNOWN_SPAN)).spanned(UNKNOWN_SPAN)),
	},
	"[" <start:Spn<ShiftExpr>?> ":" <end:Spn<ShiftExpr>?> ":" <step:Spn<ShiftExpr>> "]" => Expr::Range {
		start: Box::new(start.unwrap_or_else(||
			Expr::Literal(Literal::Number(0).spanned(UNKNOWN_SPAN)).spanned(UNKNOWN_SPAN))
		),
		end: end.map(Box::new),
		step: Box::new(step),
	},
};

LiteralExpr: Expr = {
	<RangeExpr> => <>,
	<start:@L> "%" <op:BinaryOp> <end:@R> => Expr::Fold(SpannedValue {
		start,
		end,
		value: Folder::Operator(op)
	}),
	<start:@L> "%" "(" <func:Spn<Expr>> "," <def:Spn<Expr>> <_comma:(",")?> ")" <end:@R> => Expr::Fold(
		SpannedValue {
			start,
			end,
			value: Folder::Args{func: Box::new(func), def: Box::new(def)}
		}
	),
	<Spn<FuncDef>> "@" => Expr::Mapper(Box::new(<>)),
	<Spn<Literal>> => Expr::Literal(<>),
	<e:Spn<LiteralExpr>> <r:Spn<RangeExpr>> => todo!(),
	<p:Spn<Place>> => Expr::Place(<>),
	"[" <Comma<Spn<Expr>>> "]" => Expr::Array(<>),
	"(" <Expr> ")" => <>,
};

Place: Place = {
	Spn<ident> => Place::Ident(<>),
	<e:Spn<LiteralExpr>> "." <f:Spn<ident>> => Place::Deref(Box::new(e), f.map(Rc::from)),
	<e:Spn<LiteralExpr>> "[" <i:Spn<Expr>> "]" => Place::Index(Box::new(e), Box::new(i)),
};

pub Statement: Statement = {
	<Spn<Expr>> => Statement::Expr(<>),
	<p:Spn<Place>> "=" <e:Spn<Expr>> => Statement::Assign(p, e),
};

pub File: Vec<Statement> = <mut r:(<Statement> "\n")*> <l:Statement?> => {
	match l {
		None => r,
		Some(v) => { r.push(v); r },
	}
};
