use crate::ast::{Expr, Statement, Token, Literal, BinaryOp, Place};
use std::collections::HashMap;

grammar;

extern {
	type Location = usize;
	type Error = crate::ast::UnknownToken;

	enum Token {
		number => Token::Number(<i64>),
		ident => Token::Identifier(<String>),
		str => Token::String(<String>),
		"&" => Token::And,
		"|" => Token::Pipe,
		"|>" => Token::Redirect,
		"\n" => Token::Newline,
		"(" => Token::LParen,
		")" => Token::RParen,
		"{" => Token::LBrace,
		"}" => Token::RBrace,
		"." => Token::Dot,
		"=" => Token::Equal,
		"," => Token::Comma,
		"~" => Token::Tilde,
	}
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Literal: Literal = {
	number => Literal::Number(<>),
	str => Literal::String(<>),
};

Expr: Expr = {
	<lhs:Expr> "|>" <rhs:BOrExpr> => {
		Expr::Binary(BinaryOp::Redirect, Box::new(lhs), Box::new(rhs))
	},
	<BOrExpr> => <>,
};

BOrExpr: Expr = {
	<lhs:BAndExpr> "|" <rhs:BOrExpr> => {
		Expr::Binary(BinaryOp::BitwiseOr, Box::new(lhs), Box::new(rhs))
	},
	<BAndExpr> => <>,
};

BAndExpr: Expr = {
	<lhs:MapExpr> "&" <rhs:BAndExpr> => {
		Expr::Binary(BinaryOp::BitwiseAnd, Box::new(lhs), Box::new(rhs))
	},
	<MapExpr> => <>,
};

MapField: (Expr, Expr) = {
	<Expr> "=" <Expr> => (<>),
};

StringMap: (Expr, Expr) = {
	<k:ident> "=" <v:Expr> => (Expr::Literal(Literal::String(k)), v)
};

MapExpr: Expr = {
	"~" "{" <Comma<StringMap>> "}" => Expr::Map(<>),
	"{" <Comma<MapField>> "}" => Expr::Map(<>),
	<TildeExpr> => <>,
};

TildeExpr: Expr = {
	"~" <CallExpr> => Expr::Tilde(Box::new(<>)),
	<CallExpr> => <>,
};

Named: (String, Expr) = <ident> "=" <Expr> => (<>);

NamedArgs: HashMap<String,Expr> = <args:(<Named> ",")*> <last:Named?> => {
	let mut named: HashMap<_, _> = args.into_iter().collect();
	if let Some(last) = last {
		named.insert(last.0, last.1);
	}
	named
};

PosArgs: Vec<Expr> = Comma<Expr> => <>;

CallExpr: Expr = {
	<func:CallExpr> "(" <args:PosArgs> ")" => Expr::Call {
		func: Box::new(func),
		args,
	},
	<NamedCallExpr> => <>,
};

NamedCallExpr: Expr = {
	<func:NamedCallExpr> "{" <named:NamedArgs> "}" => Expr::NamedCall {
		func: Box::new(func),
		named,
	},
	<LiteralExpr> => <>,
};

LiteralExpr: Expr = {
	<Literal> => Expr::Literal(<>),
	ident => Expr::Ident(<>),
	"(" <Expr> ")" => <>,
};

Place: Place = {
	ident => Place::Ident(<>),
	<e:ident> "." <r:Place> => Place::Deref(e, Box::new(r)),
};

pub Statement: Statement = {
	<Expr> => Statement::Expr(<>),
	<p:Place> "=" <e:Expr> => Statement::Assign(p, e),
};

pub File: Vec<Statement> = <mut r:(<Statement> "\n")*> <l:Statement?> => {
	match l {
		None => r,
		Some(v) => { r.push(v); r },
	}
};
